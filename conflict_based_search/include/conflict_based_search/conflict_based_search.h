#ifndef CONFLICT_BASED_SEARCH_H
#define CONFLICT_BASED_SEARCH_H
#include <ros/ros.h>
#include <nav_msgs/Path.h>
#include <quad_msgs/RobotPlan.h>
#include <quad_msgs/RobotState.h>
#include <quad_utils/quad_kd.h>
#include <quad_utils/ros_utils.h>
#include <quad_utils/math_utils.h>
#include <math.h>
#include <string>
#include <vector>
#include <map>
#include <limits>
#include <queue>
#include "global_body_planner/ExampleService.h"
#include "global_body_planner/global_body_planner.h"

class GraphNode{
  public:
    std::vector<std::string> robot_names_;
    std::map<std::string, quad_msgs::RobotPlan> robot_plan_map_;
    double cost;
    std::map <std::string, std::vector<std::vector<double>>> constraints_; 
    std::map <std::string, double> cost_map;
    // Positional Constraints from Other Robot

    // Constructor with parameters
    GraphNode(const std::vector<std::string>& robot_names, const std::map<std::string, quad_msgs::RobotPlan>& robot_plan_map, double cost)
        : robot_names_(robot_names), robot_plan_map_(robot_plan_map), cost(cost) {
        // Initialization of members using the provided parameters
    }

    GraphNode() {
        // Default initialization if needed
    }

    GraphNode(const std::vector<std::string>& robot_names) : robot_names_(robot_names), constraints_(), cost(std::numeric_limits<double>::infinity()){
    }

    void copyFrom(const GraphNode& source) {
        this->robot_names_ = source.robot_names_;
        this->robot_plan_map_ = source.robot_plan_map_;
        this->cost = source.cost;
        this->constraints_ = source.constraints_;
        this->cost_map = source.cost_map;
    }

    void updateCost(){
      cost = 0.0;
      for (const auto robot :robot_names_){
        cost += cost_map[robot];
      }
    }

    // Node Comparator for Priority Queue
    struct CompareCost {
        bool operator()(const GraphNode* node1, const GraphNode* node2) const {
            return node1->cost > node2->cost; // Compare based on cost (lower cost has higher priority)
        }
    };

};


class ConflictBasedSearch {
 public:
  /**
   * @brief Constructor for ConflictBasedSearch Class
   * @param[in] nh Node handle
   * @return Constructed object of type ConflictBasedSearch
   */
  ConflictBasedSearch(ros::NodeHandle nh);

  /**
   * @brief Calls ros spinOnce and pubs data at set frequency
   */
  void spin();

  /**
   * @brief Callback function to handle new plans
   * @param[in] msg Robot state trajectory message
   */


  //FUNCTIONS ADDED BY ME
  //Initializes Service Clients for Each Robot
  void createServiceClients();

  // Sends Request to Global Planner for a Initial Paths through the Enviornment
  void requestInitialPaths(GraphNode& node);

  // Sends Request to Global Planner for Path that respects constaint
  void requestPath(GraphNode& node, 
      std::tuple<std::string, std::string, int, int> conflict, bool flip);

  // Checks for Collisions between Robot Paths Generated by Global Planner
  void collisionChecker();

  // Check Intial Paths for Collisions
  void parsePaths();

  // Publish found path to the local planner
  void publishPaths(GraphNode& node);

  void printVector(const std::vector<double>& vec);

  std::vector<double> flattenConstraint(const std::vector<std::vector<double>>& input,
                                      int& originalRows, int& originalColumns);


  // ----------------Helper Functions-------------------------------------

  // Checks Every Pair of Plans for Collisions, Updates Queue
  bool doPlansCollide(GraphNode& node, std::vector<std::tuple<std::string, std::string, int, int>>& conflict_list);

  //Interpolates Time Scale of Path to Correspond to input t, Returns Interpolated State
  double interpolatePath(State state1, double t);

  // Given two inputs states, collision threshold checks pose distance for collision
  bool statesIntersect(const quad_msgs::RobotState &state_1,
                      const quad_msgs::RobotState &state_2, double threshold);

  // Returns Center of Mass Euclidean Distance Between Two Robot States
  double comDistance(const quad_msgs::RobotState &s1, const quad_msgs::RobotState &s2);

  // Generates Position Constraints from Time Conflicts
  void getConstraintFromConflict(GraphNode& node, 
          std::tuple<std::string, std::string, int, int>& conflict, 
                      std::vector<std::vector<double>>& constraints);

  void updateSuccessors(GraphNode& node1, GraphNode& node2, 
              std::tuple<std::string, std::string, int, int>& curr_conflict);

  // ----------------Helper Functions-------------------------------------

  void printRobotPlans();

  void printConstraints(std::vector<std::vector<double>>& positions);

  // std::vector<std::tuple<std::string, std::string, int, int>> conflict_list;

  std::priority_queue<GraphNode*, std::vector<GraphNode*>, GraphNode::CompareCost> queue;

  /// Nodehandle to pub to and sub from
  ros::NodeHandle nh_;

  std::vector<std::string> robot_names_;

  std::map<std::string, ros::ServiceClient> robot_clients_;

  /// ROS subscriber for incoming body plans
  std::map<std::string, ros::Publisher> robot_plan_pubs_;

  /// Mapping of Robot Names to Conflicting Unresolved Plans
  // std::map<std::string, quad_msgs::RobotPlan> robot_plan_map_;

  /// Update rate for sending and receiving data;
  double update_rate_;

  // Collision Free Paths Found
  bool pathFound;

  // Run Main Spin Once
  bool runOnce;

  bool goal_reached_;

  double threshold = 0.3;

  double time_thresh = 0.03;

  // int max_path_length_;

}; // CONFLICT_BASED_SEARCH_H

#endif  // CONFLICT_BASED_SEARCH_H
