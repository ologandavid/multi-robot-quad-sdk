#ifndef CONFLICT_BASED_SEARCH_H
#define CONFLICT_BASED_SEARCH_H
#include <ros/ros.h>
#include <nav_msgs/Path.h>
#include <quad_msgs/RobotPlan.h>
#include <quad_msgs/RobotState.h>
#include <quad_utils/quad_kd.h>
#include <quad_utils/ros_utils.h>
#include <math.h>
#include <string>
#include <vector>
#include <map>
#include "global_body_planner/ExampleService.h"

class ConflictBasedSearch {
 public:
  /**
   * @brief Constructor for ConflictBasedSearch Class
   * @param[in] nh Node handle
   * @return Constructed object of type ConflictBasedSearch
   */
  ConflictBasedSearch(ros::NodeHandle nh);

  /**
   * @brief Calls ros spinOnce and pubs data at set frequency
   */
  void spin();

  /**
   * @brief Callback function to handle new plans
   * @param[in] msg Robot state trajectory message
   */


  //FUNCTIONS ADDED BY ME
  //Initializes Service Clients for Each Robot
  void createServiceClients();

  // Sends Request to Global Planner for a Path through the Enviornment
  void requestPaths();

  //Checks for Collisions between Robot Paths Generated by Global Planner
  void collisionChecker();

  // Parse the Response Message into a useable form
  void parsePaths();


  //END OF FUNCTIONS ADDED BY ME

  /**
   * @brief Callback function to handle new plans
   * @param[in] msg Robot state trajectory message
   */
  void discreteRobotPlanCallback(const quad_msgs::RobotPlan::ConstPtr &msg, const std::string &robot_name);

  void printRobotPlans();

  /// Nodehandle to pub to and sub from
  ros::NodeHandle nh_;

  std::vector<std::string> robot_names_;

  std::map<std::string, ros::ServiceClient> robot_clients_;

  /// ROS subscriber for incoming body plans
  std::map<std::string, ros::Publisher> robot_plan_pubs_;

  /// Mapping of Robot Names to Conflicting Unresolved Plans
  std::map<std::string, quad_msgs::RobotPlan> robot_plan_map_;

  /// Update rate for sending and receiving data;
  double update_rate_;

  bool pathFound;

  // /// ROS subscriber for incoming body plans
  // std::map<std::string, ros::Subscriber> discrete_body_plan_subs_;

  // /// Most recent robot plan
  // // quad_msgs::RobotPlan::ConstPtr body_plan_msg_;
  // std::map<std::string, quad_msgs::RobotPlan::ConstPtr> body_plan_msg_;

  // /// Most recent robot plan
  // std::map<std::string, quad_msgs::RobotPlan::ConstPtr> discrete_body_plan_msg_;


}; // CONFLICT_BASED_SEARCH_H

#endif  // CONFLICT_BASED_SEARCH_H
