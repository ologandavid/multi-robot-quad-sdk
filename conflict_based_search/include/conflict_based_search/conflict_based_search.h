#ifndef CONFLICT_BASED_SEARCH_H
#define CONFLICT_BASED_SEARCH_H
#include <ros/ros.h>
#include <nav_msgs/Path.h>
#include <quad_msgs/RobotPlan.h>
#include <quad_msgs/RobotState.h>
#include <quad_utils/quad_kd.h>
#include <quad_utils/ros_utils.h>
#include <quad_utils/math_utils.h>
#include <math.h>
#include <string>
#include <vector>
#include <map>
#include "global_body_planner/ExampleService.h"
#include "global_body_planner/global_body_planner.h"

// class Conflict(){
//   public: 
//     std::string arg1; // Robot 1 Involved in Conflict
//     std::string arg2; // Robot 2 Involved in Conflict
//     void Conflict(std::string r1, std::string r2){
//       arg1 = r1;
//       arg2 = r2;
//     }

// };

class ConflictBasedSearch {
 public:
  /**
   * @brief Constructor for ConflictBasedSearch Class
   * @param[in] nh Node handle
   * @return Constructed object of type ConflictBasedSearch
   */
  ConflictBasedSearch(ros::NodeHandle nh);

  /**
   * @brief Calls ros spinOnce and pubs data at set frequency
   */
  void spin();

  /**
   * @brief Callback function to handle new plans
   * @param[in] msg Robot state trajectory message
   */


  //FUNCTIONS ADDED BY ME
  //Initializes Service Clients for Each Robot
  void createServiceClients();

  // Sends Request to Global Planner for a Path through the Enviornment
  void requestInitialPaths();

  // Checks for Collisions between Robot Paths Generated by Global Planner
  void collisionChecker();

  // Check Intial Paths for Collisions
  void parsePaths();

  // Publish found path to the local planner
  void publishPaths();


  // ----------------Helper Functions-------------------------------------

  // Checks Every Pair of Plans for Collisions, Updates Queue
  bool doPlansCollide();

  //Interpolates Time Scale of Path to Correspond to input t, Returns Interpolated State
  double interpolatePath(State state1, double t);

  // Given two inputs states, collision threshold checks pose distance for collision
  bool statesIntersect(const quad_msgs::RobotState &state_1,
                      const quad_msgs::RobotState &state_2, double threshold);

  // Returns Center of Mass Euclidean Distance Between Two Robot States
  double comDistance(const quad_msgs::RobotState &s1, const quad_msgs::RobotState &s2);

  // Generates Position Constraints from Time Conflicts
  void getConstaintFromConflict();

  // ----------------Helper Functions-------------------------------------

  void printRobotPlans();

  std::vector<std::tuple<std::string, std::string, int, int>> conflict_list;


  /// Nodehandle to pub to and sub from
  ros::NodeHandle nh_;

  std::vector<std::string> robot_names_;

  std::map<std::string, ros::ServiceClient> robot_clients_;

  /// ROS subscriber for incoming body plans
  std::map<std::string, ros::Publisher> robot_plan_pubs_;

  /// Mapping of Robot Names to Conflicting Unresolved Plans
  std::map<std::string, quad_msgs::RobotPlan> robot_plan_map_;

  /// Update rate for sending and receiving data;
  double update_rate_;

  bool pathFound;

  // std::vector<Conflict> conflict_list;

  double threshold = 0.5;

  double time_thresh = 0.03;

  int max_path_length_;

  // /// ROS subscriber for incoming body plans
  // std::map<std::string, ros::Subscriber> discrete_body_plan_subs_;

  // /// Most recent robot plan
  // // quad_msgs::RobotPlan::ConstPtr body_plan_msg_;
  // std::map<std::string, quad_msgs::RobotPlan::ConstPtr> body_plan_msg_;

  // /// Most recent robot plan
  // std::map<std::string, quad_msgs::RobotPlan::ConstPtr> discrete_body_plan_msg_;


}; // CONFLICT_BASED_SEARCH_H

#endif  // CONFLICT_BASED_SEARCH_H
